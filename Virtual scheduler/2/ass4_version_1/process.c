/***************************************************************
Operating Systems Lab Assignment 4

Name : Kumar Ayush
Roll No. 13CS10058

Name : Varun Rawal
Roll No. 13CS10059

****************************************************************/

// VIRTUAL SCHEDULER : a single process, many such processes are generated by the Generator program
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>

#define SCHEDULER_SENSE_CODE 2

#define MAX_SIZE 5
#define MSSG_Q_KEY 200

#define NOTIFY SIGUSR1 // when sent by scheduler to process
#define SUSPEND SIGUSR2	// when sent by scheduler to process

#define IO_REQUEST SIGUSR1 // when sent by process to scheduler
#define TERMINATE SIGUSR2 // when sent by process to scheduler

int suspended = 1;

void signalSender(int pid,int n,int sig)
{
	union sigval obj;
	obj.sival_int=0;

	//printf("sending SIGINT signal to %d......\n",pid);

   	if(sigqueue(pid,sig,obj) == -1)
   	{
    	perror("Signal NOT SENT...sigqueue error ! Terminating...");
    	exit(EXIT_FAILURE);
   	}			
}

void signalHandler(int sig, siginfo_t *siginfo, void *context) 
{
    // get pid of sender,
    pid_t sender_pid = siginfo->si_pid;

    if(sig == NOTIFY) 
    {
    	suspended = 0; // resume the process by setting suspended to false        
        return;
    } 
    else if(sig == SUSPEND) 
    {
       suspended = 1; // pause the process by setting suspended to true      
        return;
    }

    return;
}

struct mssg // message template for the message Queue
{
	long mtype;
	char mtext[MAX_SIZE];
};


void main(int argc,char* argv[])
{
	int scheduler_PID;
	srand(time(NULL));

	/* INSTALL THE SIGNAL_ACTION HANDLER FUNCTION***/
    struct sigaction siga;
    siga.sa_sigaction = signalHandler;
    siga.sa_flags = SA_SIGINFO; // get detailed info

    
    //sigemptyset(&siga.sa_mask);

    // change signal action,
    if(sigaction(NOTIFY, &siga, NULL) == -1) {
        printf("error in sigaction()");
        return;
    }
    if(sigaction(SUSPEND, &siga, NULL) == -1) {
        printf("error in sigaction()");
        return;
    }


	int priority,NOI,sleep_time;
	float sleep_prob;

	if(argc!=5)
	{
		printf("Please run the program with 5 arguments : <priority> <num_of_iterations> <sleep_time> <sleep_prob>\n");
		exit(1);
	}
	else
	{
		sscanf(argv[1],"%d",&priority);
		sscanf(argv[2],"%d",&NOI);
		sscanf(argv[3],"%d",&sleep_time);
		sscanf(argv[4],"%f",&sleep_prob);
	}

	int mssgQ_ID=msgget((key_t)MSSG_Q_KEY,IPC_CREAT|0666);

	//printf("mssgQ_ID : %d\n",mssgQ_ID );

	printf("Running process : PID : %d \n",getpid());

	struct mssg buffer;

	strcmp(buffer.mtext,"");
	sprintf(buffer.mtext,"CREATED %d",priority);
	buffer.mtype=SCHEDULER_SENSE_CODE;
	int retv = msgsnd(mssgQ_ID,&buffer,sizeof(buffer),0);	// blocking send

	if(retv == -1)
	{
		perror("Error : Message Queue !\n");
		exit(1);
	}
	else
	{
		//printf("retv = %d\n",retv );
	}

	//printf("Waiting for scheduler to accept my request... \n"); 
	int rcvVal = msgrcv(mssgQ_ID,&buffer,sizeof(buffer),getpid(),0); // blocking receive 
	if(rcvVal == -1)
	{
		perror("Error in mssg Q \n");
	}
	else
	{
		sscanf(buffer.mtext,"%d",&scheduler_PID); // received message from the scheduler
		//printf("Received scheduler_PID as %d\n",scheduler_PID);
		printf("Entered Ready Queue...\n");
	}
	
	int noi=0;

	for(noi=0;noi<NOI;noi++)
	{
		while(suspended)
		{
			pause();
		}	

		printf("Running iteration : %d \n",noi+1);
		usleep(6000);

		int random_integer = rand()%1000;

		float p = (float)random_integer / 1000.0;

		if(p<sleep_prob)
		{
			printf("Going for IO_REQUEST...\n");
			signalSender(scheduler_PID,0,IO_REQUEST);
			sleep(sleep_time);

			suspended=1; // bcoz now it is in waiting Queue

			printf("IO Completed...  Now Ready !\n");

			strcmp(buffer.mtext,"");
			buffer.mtype=SCHEDULER_SENSE_CODE;
			sprintf(buffer.mtext,"READY %d",priority);
			int retv = msgsnd(mssgQ_ID,&buffer,sizeof(buffer),0);	// blocking send

			if(retv == -1)
			{
				perror("Error : Message Queue unable to buffer messages !\n");
				exit(1);
			}
			else
			{
				//printf("retv = %d\n",retv );
			}
		}

				
	}

	signalSender(scheduler_PID,0,TERMINATE);
	printf("Terminating..\n");

	return;

}